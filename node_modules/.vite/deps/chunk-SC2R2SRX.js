import {
  CollectionEventType_default,
  Collection_default,
  init_Collection,
  init_CollectionEventType
} from "./chunk-X47O4RPH.js";
import {
  Base_default,
  init_Base
} from "./chunk-XQ57CBIB.js";
import {
  TileState_default,
  init_TileState
} from "./chunk-WWIYZUX6.js";
import {
  getIntersection,
  init_extent
} from "./chunk-CU5AK77I.js";
import {
  ObjectEventType_default,
  init_ObjectEventType
} from "./chunk-KKHTJBII.js";
import {
  EventType_default,
  Event_default,
  assert,
  getUid,
  init_Event,
  init_EventType,
  init_asserts,
  init_events,
  init_util,
  listen,
  unlistenByKey
} from "./chunk-OI5SM7JE.js";
import {
  clear,
  init_obj
} from "./chunk-64A63HO4.js";
import {
  __esm,
  __export
} from "./chunk-7REXU52E.js";

// node_modules/ol/structs/PriorityQueue.js
var DROP, PriorityQueue, PriorityQueue_default;
var init_PriorityQueue = __esm({
  "node_modules/ol/structs/PriorityQueue.js"() {
    init_asserts();
    init_obj();
    DROP = Infinity;
    PriorityQueue = class {
      /**
       * @param {function(T): number} priorityFunction Priority function.
       * @param {function(T): string} keyFunction Key function.
       */
      constructor(priorityFunction, keyFunction) {
        this.priorityFunction_ = priorityFunction;
        this.keyFunction_ = keyFunction;
        this.elements_ = [];
        this.priorities_ = [];
        this.queuedElements_ = {};
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        this.elements_.length = 0;
        this.priorities_.length = 0;
        clear(this.queuedElements_);
      }
      /**
       * Remove and return the highest-priority element. O(log N).
       * @return {T} Element.
       */
      dequeue() {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[0];
        if (elements.length == 1) {
          elements.length = 0;
          priorities.length = 0;
        } else {
          elements[0] = /** @type {T} */
          elements.pop();
          priorities[0] = /** @type {number} */
          priorities.pop();
          this.siftUp_(0);
        }
        const elementKey = this.keyFunction_(element);
        delete this.queuedElements_[elementKey];
        return element;
      }
      /**
       * Enqueue an element. O(log N).
       * @param {T} element Element.
       * @return {boolean} The element was added to the queue.
       */
      enqueue(element) {
        assert(
          !(this.keyFunction_(element) in this.queuedElements_),
          "Tried to enqueue an `element` that was already added to the queue"
        );
        const priority = this.priorityFunction_(element);
        if (priority != DROP) {
          this.elements_.push(element);
          this.priorities_.push(priority);
          this.queuedElements_[this.keyFunction_(element)] = true;
          this.siftDown_(0, this.elements_.length - 1);
          return true;
        }
        return false;
      }
      /**
       * @return {number} Count.
       */
      getCount() {
        return this.elements_.length;
      }
      /**
       * Gets the index of the left child of the node at the given index.
       * @param {number} index The index of the node to get the left child for.
       * @return {number} The index of the left child.
       * @private
       */
      getLeftChildIndex_(index) {
        return index * 2 + 1;
      }
      /**
       * Gets the index of the right child of the node at the given index.
       * @param {number} index The index of the node to get the right child for.
       * @return {number} The index of the right child.
       * @private
       */
      getRightChildIndex_(index) {
        return index * 2 + 2;
      }
      /**
       * Gets the index of the parent of the node at the given index.
       * @param {number} index The index of the node to get the parent for.
       * @return {number} The index of the parent.
       * @private
       */
      getParentIndex_(index) {
        return index - 1 >> 1;
      }
      /**
       * Make this a heap. O(N).
       * @private
       */
      heapify_() {
        let i;
        for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
          this.siftUp_(i);
        }
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return this.elements_.length === 0;
      }
      /**
       * @param {string} key Key.
       * @return {boolean} Is key queued.
       */
      isKeyQueued(key) {
        return key in this.queuedElements_;
      }
      /**
       * @param {T} element Element.
       * @return {boolean} Is queued.
       */
      isQueued(element) {
        return this.isKeyQueued(this.keyFunction_(element));
      }
      /**
       * @param {number} index The index of the node to move down.
       * @private
       */
      siftUp_(index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const count = elements.length;
        const element = elements[index];
        const priority = priorities[index];
        const startIndex = index;
        while (index < count >> 1) {
          const lIndex = this.getLeftChildIndex_(index);
          const rIndex = this.getRightChildIndex_(index);
          const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
          elements[index] = elements[smallerChildIndex];
          priorities[index] = priorities[smallerChildIndex];
          index = smallerChildIndex;
        }
        elements[index] = element;
        priorities[index] = priority;
        this.siftDown_(startIndex, index);
      }
      /**
       * @param {number} startIndex The index of the root.
       * @param {number} index The index of the node to move up.
       * @private
       */
      siftDown_(startIndex, index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[index];
        const priority = priorities[index];
        while (index > startIndex) {
          const parentIndex = this.getParentIndex_(index);
          if (priorities[parentIndex] > priority) {
            elements[index] = elements[parentIndex];
            priorities[index] = priorities[parentIndex];
            index = parentIndex;
          } else {
            break;
          }
        }
        elements[index] = element;
        priorities[index] = priority;
      }
      /**
       * FIXME empty description for jsdoc
       */
      reprioritize() {
        const priorityFunction = this.priorityFunction_;
        const elements = this.elements_;
        const priorities = this.priorities_;
        let index = 0;
        const n = elements.length;
        let element, i, priority;
        for (i = 0; i < n; ++i) {
          element = elements[i];
          priority = priorityFunction(element);
          if (priority == DROP) {
            delete this.queuedElements_[this.keyFunction_(element)];
          } else {
            priorities[index] = priority;
            elements[index++] = element;
          }
        }
        elements.length = index;
        priorities.length = index;
        this.heapify_();
      }
    };
    PriorityQueue_default = PriorityQueue;
  }
});

// node_modules/ol/TileQueue.js
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
var TileQueue, TileQueue_default;
var init_TileQueue = __esm({
  "node_modules/ol/TileQueue.js"() {
    init_EventType();
    init_PriorityQueue();
    init_TileState();
    TileQueue = class extends PriorityQueue_default {
      /**
       * @param {PriorityFunction} tilePriorityFunction Tile priority function.
       * @param {function(): ?} tileChangeCallback Function called on each tile change event.
       */
      constructor(tilePriorityFunction, tileChangeCallback) {
        super(
          /**
           * @param {Array} element Element.
           * @return {number} Priority.
           */
          function(element) {
            return tilePriorityFunction.apply(null, element);
          },
          /**
           * @param {Array} element Element.
           * @return {string} Key.
           */
          function(element) {
            return (
              /** @type {import("./Tile.js").default} */
              element[0].getKey()
            );
          }
        );
        this.boundHandleTileChange_ = this.handleTileChange.bind(this);
        this.tileChangeCallback_ = tileChangeCallback;
        this.tilesLoading_ = 0;
        this.tilesLoadingKeys_ = {};
      }
      /**
       * @param {Array} element Element.
       * @return {boolean} The element was added to the queue.
       * @override
       */
      enqueue(element) {
        const added = super.enqueue(element);
        if (added) {
          const tile = element[0];
          tile.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
        }
        return added;
      }
      /**
       * @return {number} Number of tiles loading.
       */
      getTilesLoading() {
        return this.tilesLoading_;
      }
      /**
       * @param {import("./events/Event.js").default} event Event.
       * @protected
       */
      handleTileChange(event) {
        const tile = (
          /** @type {import("./Tile.js").default} */
          event.target
        );
        const state = tile.getState();
        if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
          if (state !== TileState_default.ERROR) {
            tile.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
          }
          const tileKey = tile.getKey();
          if (tileKey in this.tilesLoadingKeys_) {
            delete this.tilesLoadingKeys_[tileKey];
            --this.tilesLoading_;
          }
          this.tileChangeCallback_();
        }
      }
      /**
       * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
       * @param {number} maxNewLoads Maximum number of new tiles to load.
       */
      loadMoreTiles(maxTotalLoading, maxNewLoads) {
        let newLoads = 0;
        while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
          const tile = this.dequeue()[0];
          const tileKey = tile.getKey();
          const state = tile.getState();
          if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
            this.tilesLoadingKeys_[tileKey] = true;
            ++this.tilesLoading_;
            ++newLoads;
            tile.load();
          }
        }
      }
    };
    TileQueue_default = TileQueue;
  }
});

// node_modules/ol/layer/Group.js
var Group_exports = {};
__export(Group_exports, {
  GroupEvent: () => GroupEvent,
  default: () => Group_default
});
var GroupEvent, Property, LayerGroup, Group_default;
var init_Group = __esm({
  "node_modules/ol/layer/Group.js"() {
    init_Base();
    init_Collection();
    init_CollectionEventType();
    init_Event();
    init_EventType();
    init_ObjectEventType();
    init_asserts();
    init_obj();
    init_extent();
    init_util();
    init_events();
    GroupEvent = class extends Event_default {
      /**
       * @param {GroupEventType} type The event type.
       * @param {BaseLayer} layer The layer.
       */
      constructor(type, layer) {
        super(type);
        this.layer = layer;
      }
    };
    Property = {
      LAYERS: "layers"
    };
    LayerGroup = class _LayerGroup extends Base_default {
      /**
       * @param {Options} [options] Layer options.
       */
      constructor(options) {
        options = options || {};
        const baseOptions = (
          /** @type {Options} */
          Object.assign({}, options)
        );
        delete baseOptions.layers;
        let layers = options.layers;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.layersListenerKeys_ = [];
        this.listenerKeys_ = {};
        this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);
        if (layers) {
          if (Array.isArray(layers)) {
            layers = new Collection_default(layers.slice(), { unique: true });
          } else {
            assert(
              typeof /** @type {?} */
              layers.getArray === "function",
              "Expected `layers` to be an array or a `Collection`"
            );
          }
        } else {
          layers = new Collection_default(void 0, { unique: true });
        }
        this.setLayers(layers);
      }
      /**
       * @private
       */
      handleLayerChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleLayersChanged_() {
        this.layersListenerKeys_.forEach(unlistenByKey);
        this.layersListenerKeys_.length = 0;
        const layers = this.getLayers();
        this.layersListenerKeys_.push(
          listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
          listen(
            layers,
            CollectionEventType_default.REMOVE,
            this.handleLayersRemove_,
            this
          )
        );
        for (const id in this.listenerKeys_) {
          this.listenerKeys_[id].forEach(unlistenByKey);
        }
        clear(this.listenerKeys_);
        const layersArray = layers.getArray();
        for (let i = 0, ii = layersArray.length; i < ii; i++) {
          const layer = layersArray[i];
          this.registerLayerListeners_(layer);
          this.dispatchEvent(new GroupEvent("addlayer", layer));
        }
        this.changed();
      }
      /**
       * @param {BaseLayer} layer The layer.
       */
      registerLayerListeners_(layer) {
        const listenerKeys = [
          listen(
            layer,
            ObjectEventType_default.PROPERTYCHANGE,
            this.handleLayerChange_,
            this
          ),
          listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
        ];
        if (layer instanceof _LayerGroup) {
          listenerKeys.push(
            listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
            listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
          );
        }
        this.listenerKeys_[getUid(layer)] = listenerKeys;
      }
      /**
       * @param {GroupEvent} event The layer group event.
       */
      handleLayerGroupAdd_(event) {
        this.dispatchEvent(new GroupEvent("addlayer", event.layer));
      }
      /**
       * @param {GroupEvent} event The layer group event.
       */
      handleLayerGroupRemove_(event) {
        this.dispatchEvent(new GroupEvent("removelayer", event.layer));
      }
      /**
       * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
       * @private
       */
      handleLayersAdd_(collectionEvent) {
        const layer = collectionEvent.element;
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent("addlayer", layer));
        this.changed();
      }
      /**
       * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
       * @private
       */
      handleLayersRemove_(collectionEvent) {
        const layer = collectionEvent.element;
        const key = getUid(layer);
        this.listenerKeys_[key].forEach(unlistenByKey);
        delete this.listenerKeys_[key];
        this.dispatchEvent(new GroupEvent("removelayer", layer));
        this.changed();
      }
      /**
       * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @return {!Collection<import("./Base.js").default>} Collection of
       *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
       * @observable
       * @api
       */
      getLayers() {
        return (
          /** @type {!Collection<import("./Base.js").default>} */
          this.get(Property.LAYERS)
        );
      }
      /**
       * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @param {!Collection<import("./Base.js").default>} layers Collection of
       *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
       * @observable
       * @api
       */
      setLayers(layers) {
        const collection = this.getLayers();
        if (collection) {
          const currentLayers = collection.getArray();
          for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
            this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
          }
        }
        this.set(Property.LAYERS, layers);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       * @override
       */
      getLayersArray(array) {
        array = array !== void 0 ? array : [];
        this.getLayers().forEach(function(layer) {
          layer.getLayersArray(array);
        });
        return array;
      }
      /**
       * Get the layer states list and use this groups z-index as the default
       * for all layers in this and nested groups, if it is unset at this point.
       * If dest is not provided and this group's z-index is undefined
       * 0 is used a the default z-index.
       * @param {Array<import("./Layer.js").State>} [dest] Optional list
       * of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       * @override
       */
      getLayerStatesArray(dest) {
        const states = dest !== void 0 ? dest : [];
        const pos = states.length;
        this.getLayers().forEach(function(layer) {
          layer.getLayerStatesArray(states);
        });
        const ownLayerState = this.getLayerState();
        let defaultZIndex = ownLayerState.zIndex;
        if (!dest && ownLayerState.zIndex === void 0) {
          defaultZIndex = 0;
        }
        for (let i = pos, ii = states.length; i < ii; i++) {
          const layerState = states[i];
          layerState.opacity *= ownLayerState.opacity;
          layerState.visible = layerState.visible && ownLayerState.visible;
          layerState.maxResolution = Math.min(
            layerState.maxResolution,
            ownLayerState.maxResolution
          );
          layerState.minResolution = Math.max(
            layerState.minResolution,
            ownLayerState.minResolution
          );
          layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
          layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
          if (ownLayerState.extent !== void 0) {
            if (layerState.extent !== void 0) {
              layerState.extent = getIntersection(
                layerState.extent,
                ownLayerState.extent
              );
            } else {
              layerState.extent = ownLayerState.extent;
            }
          }
          if (layerState.zIndex === void 0) {
            layerState.zIndex = defaultZIndex;
          }
        }
        return states;
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       * @override
       */
      getSourceState() {
        return "ready";
      }
    };
    Group_default = LayerGroup;
  }
});

// node_modules/ol/MapEventType.js
var MapEventType_default;
var init_MapEventType = __esm({
  "node_modules/ol/MapEventType.js"() {
    MapEventType_default = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: "movestart",
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: "moveend",
      /**
       * Triggered when loading of additional map data (tiles, images, features) starts.
       * @event module:ol/MapEvent~MapEvent#loadstart
       * @api
       */
      LOADSTART: "loadstart",
      /**
       * Triggered when loading of additional map data has completed.
       * @event module:ol/MapEvent~MapEvent#loadend
       * @api
       */
      LOADEND: "loadend"
    };
  }
});

export {
  TileQueue_default,
  getTilePriority,
  init_TileQueue,
  GroupEvent,
  Group_default,
  Group_exports,
  init_Group,
  MapEventType_default,
  init_MapEventType
};
//# sourceMappingURL=chunk-SC2R2SRX.js.map
