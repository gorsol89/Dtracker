{
  "version": 3,
  "sources": ["../../ol/layer/TileProperty.js", "../../ol/layer/BaseTile.js", "../../ol/DataTile.js", "../../ol/structs/LRUCache.js", "../../ol/vec/mat4.js", "../../ol/webgl/Canvas.js", "../../ol/reproj/glreproj.js", "../../ol/reproj/DataTile.js", "../../ol/renderer/canvas/TileLayer.js", "../../ol/layer/Tile.js"],
  "sourcesContent": ["/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n", "/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [useInterimTilesOnError=true] Deprecated.  Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n * @property {number} [cacheSize=512] The internal tile cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true,\n    );\n  }\n\n  /**\n   * @return {number|undefined} The suggested cache size\n   * @protected\n   */\n  getCacheSize() {\n    return this.cacheSize_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Deprecated.  Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Deprecated.  Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   * @override\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n", "/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * This is set as the cancellation reason when a tile is disposed.\n */\nexport const disposedError = new Error('disposed');\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true},\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @property {AbortController} [controller] An abort controller.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n\n    /**\n     * @type {AbortController|null}\n     * @private\n     */\n    this.controller_ = options.controller || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load the tile data.\n   * @api\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    if (this.controller_) {\n      this.controller_.abort(disposedError);\n      this.controller_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default DataTile;\n", "/**\n * @module ol/structs/LRUCache\n */\n\nimport Disposable from '../Disposable.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  deleteOldest() {\n    const entry = this.pop();\n    if (entry instanceof Disposable) {\n      entry.dispose();\n    }\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},\n   * the entry will be disposed.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    while (this.oldest_) {\n      this.deleteOldest();\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache',\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already',\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n", "/**\n * @module ol/vec/mat4\n */\n\n/** @typedef {Array<number>} Mat4 */\n\n/**\n * @return {Mat4} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\n/**\n * @param {Mat4} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Mat4} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n  mat4[0] = transform[0];\n  mat4[1] = transform[1];\n  mat4[4] = transform[2];\n  mat4[5] = transform[3];\n  mat4[12] = transform[4];\n  mat4[13] = transform[5];\n  return mat4;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @param {Mat4} [out] mat4 frustum matrix will be written into\n * @return {Mat4} out\n */\nexport function orthographic(left, right, bottom, top, near, far, out) {\n  out = out ?? create();\n  const lr = 1 / (left - right),\n    bt = 1 / (bottom - top),\n    nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3\n *\n * @param {Mat4} m The matrix to scale.\n * @param {number} x How much to scale in the x direction.\n * @param {number} y How much to scale in the y direction.\n * @param {number} z How much to scale in the z direction.\n * @param {Mat4} [out] The matrix to write to.\n * @return {Mat4} out\n **/\nexport function scale(m, x, y, z, out) {\n  out = out ?? create();\n  out[0] = m[0] * x;\n  out[1] = m[1] * x;\n  out[2] = m[2] * x;\n  out[3] = m[3] * x;\n  out[4] = m[4] * y;\n  out[5] = m[5] * y;\n  out[6] = m[6] * y;\n  out[7] = m[7] * y;\n  out[8] = m[8] * z;\n  out[9] = m[9] * z;\n  out[10] = m[10] * z;\n  out[11] = m[11] * z;\n  out[12] = m[12];\n  out[13] = m[13];\n  out[14] = m[14];\n  out[15] = m[15];\n  return out;\n}\n\n/**\n * Translate a matrix.\n *\n * @param {Mat4} m the matrix to translate\n * @param {number} x How much to translate in the x direction.\n * @param {number} y How much to translate in the y direction.\n * @param {number} z How much to translate in the z direction.\n * @param {Mat4} [out] the receiving matrix\n * @return {Mat4} out\n */\nexport function translate(m, x, y, z, out) {\n  out = out ?? create();\n  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;\n\n  if (m === out) {\n    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];\n    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];\n    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];\n    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];\n  } else {\n    a00 = m[0];\n    a01 = m[1];\n    a02 = m[2];\n    a03 = m[3];\n    a10 = m[4];\n    a11 = m[5];\n    a12 = m[6];\n    a13 = m[7];\n    a20 = m[8];\n    a21 = m[9];\n    a22 = m[10];\n    a23 = m[11];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n\n    out[12] = a00 * x + a10 * y + a20 * z + m[12];\n    out[13] = a01 * x + a11 * y + a21 * z + m[13];\n    out[14] = a02 * x + a12 * y + a22 * z + m[14];\n    out[15] = a03 * x + a13 * y + a23 * z + m[15];\n  }\n\n  return out;\n}\n\n/**\n * @param {number} x x translation.\n * @param {number} y y translation.\n * @param {number} z z translation.\n * @param {Mat4} [out] optional matrix to store result\n * @return {Mat4} out\n */\nexport function translation(x, y, z, out) {\n  out = out ?? create();\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = x;\n  out[13] = y;\n  out[14] = z;\n  out[15] = 1;\n\n  return out;\n}\n", "import * as mat4 from '../vec/mat4.js';\n\n/**\n * @module ol/webgl/Canvas\n */\n\nconst VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec4 a_texcoord;\n\n  uniform mat4 u_matrix;\n  uniform mat4 u_textureMatrix;\n\n  varying vec2 v_texcoord;\n\n  void main() {\n    gl_Position = u_matrix * a_position;\n    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;\n    v_texcoord = texcoord;\n  }\n`;\n\nconst FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (\n      v_texcoord.x < 0.0 ||\n      v_texcoord.y < 0.0 ||\n      v_texcoord.x > 1.0 ||\n      v_texcoord.y > 1.0\n    ) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/** @typedef {import(\"../transform.js\").Transform} Matrix */\n\n/**\n * Canvas-like operations implemented in webgl.\n */\nexport class Canvas {\n  /**\n   * @param {WebGLRenderingContext} gl Context to render in.\n   */\n  constructor(gl) {\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = gl;\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.program_ = createProgram(gl, FRAGMENT_SHADER, VERTEX_SHADER);\n\n    this.positionLocation = gl.getAttribLocation(this.program_, 'a_position');\n    this.texcoordLocation = gl.getAttribLocation(this.program_, 'a_texcoord');\n\n    this.matrixLocation = gl.getUniformLocation(this.program_, 'u_matrix');\n    this.textureMatrixLocation = gl.getUniformLocation(\n      this.program_,\n      'u_textureMatrix',\n    );\n    this.textureLocation = gl.getUniformLocation(this.program_, 'u_texture');\n\n    this.positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n\n    this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.positions),\n      gl.STATIC_DRAW,\n    );\n\n    this.texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n\n    this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1];\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(this.texcoords),\n      gl.STATIC_DRAW,\n    );\n  }\n\n  /**\n   * 2dContext drawImage call implemented in webgl.\n   * Unlike images, textures do not have a width and height associated\n   * with them so we'll pass in the width and height of the texture.\n   *\n   * @param {WebGLTexture} tex Image to draw.\n   * @param {number} texWidth Image width.\n   * @param {number} texHeight Image height.\n   * @param {number} srcX Top-left x-point to read src image.\n   * @param {number} srcY Top-left y-point to read src image.\n   * @param {number} [srcWidth] Width of source to read.\n   * @param {number} [srcHeight] Height of source to read.\n   * @param {number} [dstX] Top-left x-point of destination.\n   * @param {number} [dstY] Top-left y-point of destination.\n   * @param {number} [dstWidth] Width of written image in destination.\n   * @param {number} [dstHeight] Height of written image in destination.\n   * @param {number} [width] Width of canvas.\n   * @param {number} [height] Height of canvas.\n   */\n  drawImage(\n    tex,\n    texWidth,\n    texHeight,\n    srcX,\n    srcY,\n    srcWidth,\n    srcHeight,\n    dstX,\n    dstY,\n    dstWidth,\n    dstHeight,\n    width,\n    height,\n  ) {\n    const gl = this.gl_;\n\n    if (dstX === undefined) {\n      dstX = srcX;\n    }\n    if (dstY === undefined) {\n      dstY = srcY;\n    }\n    if (srcWidth === undefined) {\n      srcWidth = texWidth;\n    }\n    if (srcHeight === undefined) {\n      srcHeight = texHeight;\n    }\n    if (dstWidth === undefined) {\n      dstWidth = srcWidth;\n    }\n    if (dstHeight === undefined) {\n      dstHeight = srcHeight;\n    }\n    if (width === undefined) {\n      width = gl.canvas.width;\n    }\n    if (height === undefined) {\n      height = gl.canvas.height;\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n\n    gl.useProgram(this.program_);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);\n    gl.enableVertexAttribArray(this.texcoordLocation);\n    gl.vertexAttribPointer(this.texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // matrix for converting pixels to clip space\n    let matrix = mat4.orthographic(0, width, 0, height, -1, 1);\n    matrix = mat4.translate(matrix, dstX, dstY, 0);\n    matrix = mat4.scale(matrix, dstWidth, dstHeight, 1);\n    gl.uniformMatrix4fv(this.matrixLocation, false, matrix);\n\n    let texMatrix = mat4.translation(srcX / texWidth, srcY / texHeight, 0);\n    texMatrix = mat4.scale(\n      texMatrix,\n      srcWidth / texWidth,\n      srcHeight / texHeight,\n      1,\n    );\n\n    gl.uniformMatrix4fv(this.textureMatrixLocation, false, texMatrix);\n    gl.uniform1i(this.textureLocation, 0);\n    gl.drawArrays(gl.TRIANGLES, 0, this.positions.length / 2);\n  }\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {GLenum} type Type of shader.\n * @param {string} source source of shader.\n * @return {WebGLShader} [progam] The program.\n */\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  if (shader === null) {\n    throw new Error('Shader compilation failed');\n  }\n\n  gl.shaderSource(shader, source);\n\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const log = gl.getShaderInfoLog(shader);\n    if (log === null) {\n      throw new Error('Shader info log creation failed');\n    }\n    throw new Error(log);\n  }\n\n  return shader;\n}\n\n/**\n * @param {WebGLRenderingContext} gl Rendering Context.\n * @param {string} fragmentSource Fragment shader source.\n * @param {string} vertexSource Vertex shader source.\n * @return {WebGLProgram} [progam] The program.\n */\nexport function createProgram(gl, fragmentSource, vertexSource) {\n  const program = gl.createProgram();\n\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n  if (program === null) {\n    throw new Error('Program creation failed');\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    const log = gl.getProgramInfoLog(program);\n    if (log === null) {\n      throw new Error('Program info log creation failed');\n    }\n    throw new Error();\n  }\n  return program;\n}\n", "/**\n * @module ol/reproj/glreproj\n */\nimport * as mat4 from '../vec/mat4.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../has.js';\nimport {Canvas as WebGLCanvas, createProgram} from '../webgl/Canvas.js';\nimport {\n  createEmpty,\n  extend,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from '../extent.js';\n\nconst EDGE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n  }\n`;\nconst EDGE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  uniform vec4 u_val;\n  void main() {\n     gl_FragColor = u_val;\n  }\n`;\n\nconst TRIANGLE_VERTEX_SHADER = `\n  attribute vec4 a_position;\n  attribute vec2 a_texcoord;\n\n  varying vec2 v_texcoord;\n\n  uniform mat4 u_matrix;\n\n  void main() {\n     gl_Position = u_matrix * a_position;\n     v_texcoord = a_texcoord;\n  }\n`;\nconst TRIANGLE_FRAGMENT_SHADER = `\n  precision mediump float;\n\n  varying vec2 v_texcoord;\n\n  uniform sampler2D u_texture;\n\n  void main() {\n    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {\n      discard;\n    }\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n  }\n`;\n\n/**\n * Create an html canvas element and returns its webgl context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement | OffscreenCanvas>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {WebGLContextAttributes} [settings] CanvasRenderingContext2DSettings\n * @return {WebGLRenderingContext} The context.\n */\nexport function createCanvasContextWebGL(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = /** @type {HTMLCanvasElement} */ (canvasPool.shift());\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {WebGLRenderingContext} */ (\n    canvas.getContext('webgl', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {WebGLRenderingContext} gl Context.\n */\nexport function releaseGLCanvas(gl) {\n  const canvas = gl.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n}\n\n/**\n * @type {Array<HTMLCanvasElement | OffscreenCanvas>}\n */\nexport const canvasGLPool = [];\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"../extent.js\").Extent} extent Extent.\n * @property {import(\"../extent.js\").Extent} [clipExtent] Clip extent.\n * @property {WebGLTexture} texture Texture.\n * @property {number} width Width of texture.\n * @property {number} height Height of texture.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {WebGLRenderingContext} gl the context to render in.\n * @param {number} width_ Width of the canvas.\n * @param {number} height_ Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"../extent.js\").Extent} targetExtent Target extent (tile).\n * @param {import(\"../reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {number} dataType What kind of data is the textures, must be gl.FLOAT or gl.UNSIGNED_BYTE\n * TODO: Allow setting renderEdges value in the data as this is done in \"data-space\".\n * @param {boolean | Array<number>} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchTexture.\n * @return {{framebuffer: WebGLFramebuffer, width: number, height: number, texture: WebGLTexture}} Canvas with reprojected data.\n */\nexport function render(\n  gl,\n  width_,\n  height_,\n  pixelRatio,\n  sourceResolution,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  dataType,\n  renderEdges,\n  interpolate,\n  drawSingle,\n) {\n  const width = Math.round(pixelRatio * width_);\n  const height = Math.round(pixelRatio * height_);\n  gl.canvas.width = width;\n  gl.canvas.height = height;\n\n  /** @type {WebGLFramebuffer | null} */\n  let resultFrameBuffer;\n  /** @type {WebGLTexture | null} */\n  let resultTexture;\n  {\n    resultTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, resultTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    resultFrameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      resultTexture,\n      0,\n    );\n  }\n\n  if (resultFrameBuffer === null) {\n    throw new Error('Could not create framebuffer');\n  }\n  if (resultTexture === null) {\n    throw new Error('Could not create texture');\n  }\n\n  if (sources.length === 0) {\n    return {\n      width,\n      height,\n      framebuffer: resultFrameBuffer,\n      texture: resultTexture,\n    };\n  }\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  /** @type {WebGLTexture | null} */\n  let stitchTexture;\n  /** @type {number} */\n  let stitchWidth;\n  /** @type {number} */\n  let stitchHeight;\n  const stitchScale = 1 / sourceResolution;\n\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    stitchTexture = gl.createTexture();\n    if (resultTexture === null) {\n      throw new Error('Could not create texture');\n    }\n    stitchWidth = Math.round(getWidth(sourceDataExtent) * stitchScale);\n    stitchHeight = Math.round(getHeight(sourceDataExtent) * stitchScale);\n\n    // Make sure we do not exceed the max texture size by lowering the resolution for this image.\n    // https://github.com/openlayers/openlayers/pull/15860#issuecomment-2254123580\n    const maxTexSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    const largeSide = Math.max(stitchWidth, stitchHeight);\n    const scaleFactor = largeSide > maxTexSize ? maxTexSize / largeSide : 1;\n    const stitchWidthFixed = Math.round(stitchWidth * scaleFactor);\n    const stitchHeightFixed = Math.round(stitchHeight * scaleFactor);\n\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    if (interpolate) {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    }\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      stitchWidthFixed,\n      stitchHeightFixed,\n      0,\n      gl.RGBA,\n      dataType,\n      null,\n    );\n\n    const fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      stitchTexture,\n      0,\n    );\n    const webGLCanvas = new WebGLCanvas(gl);\n\n    sources.forEach(function (src, i, arr) {\n      const xPos =\n        (src.extent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n      const yPos =\n        -(src.extent[3] - sourceDataExtent[3]) * stitchScale * scaleFactor;\n      const srcWidth = getWidth(src.extent) * stitchScale * scaleFactor;\n      const srcHeight = getHeight(src.extent) * stitchScale * scaleFactor;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n      gl.viewport(0, 0, stitchWidthFixed, stitchHeightFixed);\n\n      if (src.clipExtent) {\n        const xPos =\n          (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale * scaleFactor;\n        const yPos =\n          -(src.clipExtent[3] - sourceDataExtent[3]) *\n          stitchScale *\n          scaleFactor;\n        const width = getWidth(src.clipExtent) * stitchScale * scaleFactor;\n        const height = getHeight(src.clipExtent) * stitchScale * scaleFactor;\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(\n          interpolate ? xPos : Math.round(xPos),\n          interpolate ? yPos : Math.round(yPos),\n          interpolate ? width : Math.round(xPos + width) - Math.round(xPos),\n          interpolate ? height : Math.round(yPos + height) - Math.round(yPos),\n        );\n      }\n\n      webGLCanvas.drawImage(\n        src.texture,\n        src.width,\n        src.height,\n        gutter,\n        gutter,\n        src.width - 2 * gutter,\n        src.height - 2 * gutter,\n        interpolate ? xPos : Math.round(xPos),\n        interpolate ? yPos : Math.round(yPos),\n        interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),\n        interpolate\n          ? srcHeight\n          : Math.round(yPos + srcHeight) - Math.round(yPos),\n        stitchWidthFixed,\n        stitchHeightFixed,\n      );\n\n      gl.disable(gl.SCISSOR_TEST);\n    });\n    gl.deleteFramebuffer(fb);\n  } else {\n    stitchTexture = sources[0].texture;\n    stitchWidth = sources[0].width;\n    stitchHeight = sources[0].width;\n  }\n\n  const targetTopLeft = getTopLeft(targetExtent);\n  const sourceTopLeft = getTopLeft(sourceDataExtent);\n\n  const getUVs = (\n    /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ target,\n  ) => {\n    const u0 =\n      ((target[0][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v0 =\n      (-(target[0][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u1 =\n      ((target[1][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v1 =\n      (-(target[1][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    const u2 =\n      ((target[2][0] - targetTopLeft[0]) / targetResolution) * pixelRatio;\n    const v2 =\n      (-(target[2][1] - targetTopLeft[1]) / targetResolution) * pixelRatio;\n    return {u1, v1, u0, v0, u2, v2};\n  };\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, resultFrameBuffer);\n  gl.viewport(0, 0, width, height);\n\n  // Draw source to reprojtile\n  {\n    /** @type {Array<number>} */\n    const vertices = [];\n    /** @type {Array<number>} */\n    const texcoords = [];\n\n    const triProgram = createProgram(\n      gl,\n      TRIANGLE_FRAGMENT_SHADER,\n      TRIANGLE_VERTEX_SHADER,\n    );\n    gl.useProgram(triProgram);\n\n    // Bind image\n    const textureLocation = gl.getUniformLocation(triProgram, 'u_texture');\n    gl.bindTexture(gl.TEXTURE_2D, stitchTexture);\n\n    // Tell the shader to get the texture from texture unit 0\n    gl.uniform1i(textureLocation, 0);\n\n    // Calculate vert and tex coordinates.\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const source = triangle.source;\n      const target = triangle.target;\n      // Make sure that everything is on pixel boundaries\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      const su0 =\n        (source[0][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv0 =\n        -(source[0][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su1 =\n        (source[1][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv1 =\n        -(source[1][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n      const su2 =\n        (source[2][0] - sourceTopLeft[0]) / sourceResolution / stitchWidth;\n      const sv2 =\n        -(source[2][1] - sourceTopLeft[1]) / sourceResolution / stitchHeight;\n\n      vertices.push(u1, v1, u0, v0, u2, v2);\n      texcoords.push(su1, sv1, su0, sv0, su2, sv2);\n    });\n\n    // Convert pixel space to clip space.\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(triProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const positionLocation = gl.getAttribLocation(triProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    const texcoordLocation = gl.getAttribLocation(triProgram, 'a_texcoord');\n    const texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);\n  }\n\n  if (renderEdges) {\n    const edgeProgram = createProgram(\n      gl,\n      EDGE_FRAGMENT_SHADER,\n      EDGE_VERTEX_SHADER,\n    );\n    gl.useProgram(edgeProgram);\n    const matrix = mat4.orthographic(0, width, height, 0, -1, 1);\n    const matrixLocation = gl.getUniformLocation(edgeProgram, 'u_matrix');\n    gl.uniformMatrix4fv(matrixLocation, false, matrix);\n\n    const burnval = Array.isArray(renderEdges) ? renderEdges : [0, 0, 0, 255];\n    const burnvalLocation = gl.getUniformLocation(edgeProgram, 'u_val');\n    const isFloat = true;\n    if (isFloat) {\n      gl.uniform4fv(burnvalLocation, burnval);\n    } else {\n      gl.uniform4iv(burnvalLocation, burnval);\n    }\n\n    const positionLocation = gl.getAttribLocation(edgeProgram, 'a_position');\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionLocation);\n\n    /** @type {Array<number>} */\n    const lines = triangulation.getTriangles().reduce(function (\n      /** @type {Array<number>} */ lines,\n      triangle,\n    ) {\n      const target = triangle.target;\n      const {u1, v1, u0, v0, u2, v2} = getUVs(target);\n\n      return lines.concat([u1, v1, u0, v0, u0, v0, u2, v2, u2, v2, u1, v1]);\n    }, []);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);\n    gl.drawArrays(gl.LINES, 0, lines.length / 2);\n  }\n\n  return {\n    width,\n    height,\n    framebuffer: resultFrameBuffer,\n    texture: resultTexture,\n  };\n}\n", "/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {calculateSourceExtentResolution} from '../reproj.js';\nimport {\n  canvasGLPool,\n  createCanvasContextWebGL,\n  releaseGLCanvas,\n  render as renderReprojected,\n} from './glreproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {import(\"../transform.js\").Transform} [transformMatrix] Source transform matrix.\n * @property {boolean} [renderEdges] Render reprojection edges.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8ClampedArray(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {boolean | Array<number>}\n     */\n    this.renderEdges_ =\n      options.renderEdges !== undefined ? options.renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n      options.transformMatrix,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   * @override\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   * @override\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @override\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    let imageLike = false;\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        imageLike = true;\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8ClampedArray;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: tileDataR,\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n        bandCount: bandCount,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n      this.changed();\n      return;\n    }\n\n    const z = this.wrappedTileCoord_[0];\n    const size = this.targetTileGrid_.getTileSize(z);\n    const targetWidth = typeof size === 'number' ? size : size[0];\n    const targetHeight = typeof size === 'number' ? size : size[1];\n    const outWidth = targetWidth * this.pixelRatio_;\n    const outHeight = targetHeight * this.pixelRatio_;\n    const targetResolution = this.targetTileGrid_.getResolution(z);\n    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n\n    const bandCount = dataSources[0].bandCount;\n    const dataR = new dataSources[0].dataType(bandCount * outWidth * outHeight);\n\n    const gl = createCanvasContextWebGL(outWidth, outHeight, canvasGLPool, {\n      premultipliedAlpha: false,\n      antialias: false,\n    });\n\n    let willInterpolate;\n    const format = gl.RGBA;\n    let textureType;\n    if (dataSources[0].dataType == Float32Array) {\n      textureType = gl.FLOAT;\n      gl.getExtension('WEBGL_color_buffer_float');\n      gl.getExtension('OES_texture_float');\n      gl.getExtension('EXT_float_blend');\n      const extension = gl.getExtension('OES_texture_float_linear');\n      const canInterpolate = extension !== null;\n      willInterpolate = canInterpolate && this.interpolate;\n    } else {\n      textureType = gl.UNSIGNED_BYTE;\n      willInterpolate = this.interpolate;\n    }\n\n    const BANDS_PR_REPROJ = 4;\n    const reprojs = Math.ceil(bandCount / BANDS_PR_REPROJ);\n    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n      const sources = [];\n      for (let i = 0, len = dataSources.length; i < len; ++i) {\n        const dataSource = dataSources[i];\n\n        const pixelSize = dataSource.pixelSize;\n        const width = pixelSize[0];\n        const height = pixelSize[1];\n\n        const data = new dataSource.dataType(BANDS_PR_REPROJ * width * height);\n        const dataS = dataSource.data;\n        let offset = reproj * BANDS_PR_REPROJ;\n        for (let j = 0, len = data.length; j < len; j += BANDS_PR_REPROJ) {\n          data[j] = dataS[offset];\n          data[j + 1] = dataS[offset + 1];\n          data[j + 2] = dataS[offset + 2];\n          data[j + 3] = dataS[offset + 3];\n          offset += bandCount;\n        }\n\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        if (willInterpolate) {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        } else {\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          format,\n          width,\n          height,\n          0,\n          format,\n          textureType,\n          data,\n        );\n\n        sources.push({\n          extent: dataSource.extent,\n          clipExtent: dataSource.clipExtent,\n          texture: texture,\n          width: width,\n          height: height,\n        });\n      }\n\n      const {framebuffer, width, height} = renderReprojected(\n        gl,\n        targetWidth,\n        targetHeight,\n        this.pixelRatio_,\n        sourceResolution,\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        textureType,\n        this.renderEdges_,\n        willInterpolate,\n      );\n\n      // The texture is always RGBA.\n      const rows = width;\n      const cols = height * BANDS_PR_REPROJ;\n      const data = new dataSources[0].dataType(rows * cols);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n      gl.readPixels(0, 0, width, height, gl.RGBA, textureType, data);\n\n      let offset = reproj * BANDS_PR_REPROJ;\n      for (let i = 0, len = data.length; i < len; i += BANDS_PR_REPROJ) {\n        // The data read by `readPixels` is flipped in the y-axis so flip it again.\n        const flipY = (rows - 1 - ((i / cols) | 0)) * cols + (i % cols);\n        dataR[offset] = data[flipY];\n        dataR[offset + 1] = data[flipY + 1];\n        dataR[offset + 2] = data[flipY + 2];\n        dataR[offset + 3] = data[flipY + 3];\n        offset += bandCount;\n      }\n    }\n\n    releaseGLCanvas(gl);\n    canvasGLPool.push(gl.canvas);\n\n    if (imageLike) {\n      const context = createCanvasContext2D(targetWidth, targetHeight);\n      const imageData = new ImageData(dataR, targetWidth);\n      context.putImageData(imageData, 0, 0);\n      this.reprojData_ = context.canvas;\n    } else {\n      this.reprojData_ = dataR;\n    }\n    this.reprojSize_ = [Math.round(outWidth), Math.round(outHeight)];\n    this.state = TileState.LOADED;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @override\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(tile, EventType.CHANGE, () => {\n        const state = tile.getState();\n        if (\n          state == TileState.LOADED ||\n          state == TileState.ERROR ||\n          state == TileState.EMPTY\n        ) {\n          unlistenByKey(sourceListenKey);\n          leftToLoad--;\n          if (leftToLoad === 0) {\n            this.unlistenSources_();\n            this.reproject_();\n          }\n        }\n      });\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n", "/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.get(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.get(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    let allTilesIdle = true;\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  * maybe skip transition when not fully opaque\n     *  * decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tileState === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.IDLE) {\n        allTilesIdle = false;\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n    if (!this.renderComplete && !allTilesIdle) {\n      frameState.animate = true;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n", "/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} [TileSourceType=import(\"../source/Tile.js\").default]\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * @override\n   */\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this, {\n      cacheSize: this.getCacheSize(),\n    });\n  }\n}\n\nexport default TileLayer;\n"],
  "mappings": "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",
  "names": ["xPos", "yPos", "width", "height", "lines", "DataTile_default", "init_DataTile", "size", "bandCount", "width", "height", "data", "offset", "len", "state", "init_Layer", "init_DataTile", "init_Tile", "Layer_default", "Tile_default", "DataTile_default", "dx", "dy", "i", "frameState", "Tile_default", "init_Tile"]
}
